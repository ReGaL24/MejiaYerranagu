\section{Architectural Design}
\subsection{Overview}

This section aims to provide a high-level description of the architecture of the BestBikePaths (BBP) system and outlines the main architectural layers, the core components and their interactions. This layered organization facilitates a clear allocation of responsibilities and interactions across the system components. This section also validates the modeling decisions made to satisfy both the functional and non-functional requirements of the system. 


\subsubsection{System View}

The chosen optimal architectural solution for the BBP system is a 4-tier architecture, consisting of clearly separated presentation layer, two application layers - a server side layer and a second microservice layer, and a data layer. This structure allows for a modular development with easier maintenance, and scalability.

The presentation layer resides on the client side, implemented as a native mobile application for iOS and Android platforms, that will be responsible for all system functionality such as user interaction, trip recording, and visualization of bike paths and trip statistics. This mobile first approach prioritizes user experience and accessibility, where users can interact with the smartphone while cycling.

The server side application layer has been divided into 2 parts where the first part is the API Gateway and proxy management, which serves as the main entry point for all client requests. It handles authentication, routing, and rate limiting, and more importantly insulates the backend services from direct exposure to the internet, applying consistent security policies and request routing. The second part of the application layer consists of multiple microservices which make up the core functioning of the BBP system, each responsible for a specific functionality such as trip recording services, path services, user authentication, weather integration, and notifications services. This microservice architecture allows for independent development, deployment, and scaling of each service on a rapid scale.

The data layer consists of a relational database management system (PostgreSQL) for persistent storage of user data, trips, paths, and other relevant information. 

The flow of information between the layers is as follows: the client-side mobile application collects GPS data, user inputs and path information and then sends the requests to the API Gateway which enforces security and rate-limiting policies, which then routes them to the appropriate backend microservice based on the request type. Each microservice then processes the request calling on any external systems if required, interacts with the database as needed, and returns the formatted response back through the API Gateway to the client application .


\subsubsection{Detailed View}

\textbf{Presentation Tier}

The user interacts with the BBP system exclusively through a mobile application (iOS and Android) installed on their smartphone. The mobile application is responsible for collecting user inputs through a touch friendly interface, optimized for on the go use by the cyclists using it. The application acquires the GPS data from the device location services during bike trips, allowing users to enter bike paths, and also displays trip statistics and path information. The app communicates with the backend services via HTTPS REST request through the API Gateway to transmit collected data, query for bike paths, and retrieve user information and also displays the responses from the backend in a user-friendly manner: real-time trip metrics, path maps, notifications, etc. The mobile application also facilitates offline capabilities by locally buffering GPS data during trips when network connectivity is unavailable, and then synchronizing the data with the backend once connectivity is restored ensuring data integrity. This feature is critical for those who may cycle through areas with poor network coverage.

\textbf{Application Tier - Frontend}

This application tier serves as the main entry point for all client requests and acts as a buffer between the mobile client and the core backend services. This mainly handles authentication, routing, and rate limiting, and more importantly insulates the backend services from direct exposure to the internet, applying consistent security policies and request routing. The Front End of the application layer mainly consists of Proxy manager, API Gateway and Proxy for External API calls.

Proxy Manager manages incoming requests from the mobile application, enforcing security policies such as handling SSL/TLS certificate management and its renewal, decryption of incoming HTTPS requests often acting as a first security layer. It ensures that only authorized requests reach the backend services.

API Gateway serves as the main entry point for all client requests. It handles authentication and authorization by extracting the authentication token identifying the user identity and role - \verb|RegisteredUser| or \verb|UnregisteredUser|. It routes requests to the appropriate backend microservice based on the request type, ensuring that each service only receives relevant requests. Rate limiting is implemented to prevent abuse and ensure the protection of the backend services from denial-of-service attacks. Further Load balancing is also implemented to distribute incoming requests evenly across multiple instances of backend services, ensuring optimal resource utilization and responsiveness. Caching of frequently requested data is also implemented to reduce database load, latency and improve responsive performance.

Proxy for External API Calls manages outbound requests to third-party services such as OpenWeather API for weather data, OpenStreetMap for map data and OAuth providers for user authentication. It handles the communication protocols incase any external API are offline by implementing timeout policies and retry logic with backoff for failure to ensure that these external service unavailable doesn't degrade BBP system functionality.

\textbf{Application Tier - Backend}

The backend application tier consists of multiple microservices, each responsible for a specific functionality within the BBP system. The core microservices include:
\begin{itemize}
    \item User Authentication Service: Manages user registration, login, OAuth federation, and token issuance for secure access to the system.
    \item Trip Recording Service: Responsible for acquiring GPS data during bike trips, computing trip statistics (distance, duration, speed, elevation gain), and storing trip data.
    \item Path Management Service: Manages the creation, and publishing of bike paths by \verb|RegisteredUser|, including obstacle information.
    \item Path Scoring Service: Handles the computation of a path score value based on path conditions and obstacles and path ranking so it can order and effectively prioritize paths for visualization.
    \item Geocoding Integration Service: This component communicates directly with the external geocoding service, described in the External Services section below. It exposes a clean internal interface to uniformly resolve geographic locations and manage failures and eventual service unavailability. 
    \item Weather Integration Service: Integrates with the OpenWeather API to enrich trip data with weather information at the time and location of the trip.
    \item Notification Service: Sends in-app and push notifications to users for important events such as trip completion, path publication, and weather alerts.
\end{itemize}
These microservices are independently deployable and scalable, allowing for rapid development and updates without affecting the entire system. They communicate with each other using RESTful APIs for event-driven interactions.

\newpage
\textbf{Data Tier}

The data layer is essential for overseeing the system's information all while offering efficient access to application elements. The database provides a primary persistent storage solution for user data, trips, paths, and other relevant information such as weather snapshot and geocoding cache. The database is configured with a clustered setup with replication to ensure high availability and fault tolerance. Each microservice interacts with the database through well-defined schema for its entities, enabling data isolation.


\subsection{Component View}

The following component view organizes the BBP system into presentation (mobile client), application (frontend and backend), data and external components layers to clearly separate responsibilities. The core functionality is relayed to the application layer while the user interaction is described in the presentation layer. This also allows us to declare third party services as external dependencies with their corresponding considerations. 

\textbf{Presentation Layer}

These components reside entirely on the user’s mobile device.

\begin{itemize}
    \item Mobile User Interface: The component that interacts directly with the users. It is responsible for rendering screens, maps and user interactions. It adapts functionality and navigation features depending on the type of user (registered/unregistered). It communicates with the backend through a direct connection to the API Gateway.
    \item Device Sensors Adapter: It interacts with platform-specific interfaces to access the device GPS, accelerometer and gyroscope APIs, both for Android and iOS systems. This component is also in charge of providing sensor data to the Path Management Service.
    \item Cache Server Adapter: This component manages local data buffering when the device is offline. It stores GPS data during trips and synchronizes it with the Trip Recording Service once connectivity is restored.
\end{itemize}

\textbf{Application Layer}

These components run on backend infrastructure and expose the system’s core functionality.

\begin{itemize}
    \item API Gateway: This component acts as the only entry point for all client requests by exposing an API to the mobile client. It routes each request to the appropriate application components and enforces the necessary security mechanisms (authentication, rate limits).
    \item User Authentication Service: This component oversees managing user accounts, credentials and sessions. It validates authentication tokens and controls access to restricted functionalities, specifically when regarding the distinction between registered and unregistered users. Thus, it supports both authenticated and guest sessions.
    \item Trip Recording Service: This component is responsible for managing a trip state during recording (play, pause, stop). It also handles the storage and retrieval of previously recorded trips. It can compute and persist relevant trip statistics to deliver them to the User Interface. It manages trip lifecycle states like recorded, processed, enriched, and communicates with Weather Integration Service to retrieve and store additional trip information. Since this service displays trips for the user, it retrieves coordinates data from the Geocoding Integration Service.
    \item Path Management Service: This component manages bike path data contributed by users. It handles both manual path insertion and automatic path data collection. It is also in charge of enforcing publication and visibility rules and managing users path reviews for the automatic case. This component also enables path discovery functionality with the support of the Geocoding Integration Service and Path Scoring Service, which can be accessed by registered and unregistered users.
    \item Path Scoring Service: This component handles the computation of a path score value based on path conditions and obstacles. It also handles path ranking so it can order and effectively prioritize paths for further visualization. It encapsulates scoring logic, so it is kept independent from path management and storage.
    \item Geocoding Integration Service: This component communicates directly with the external geocoding service, described in the External Services section below. It exposes a clean internal interface to uniformly resolve geographic locations and manage failures and eventual service unavailability. 
    \item Weather Integration Service: This component communicates directly with the external weather service, described in the External Services section below. It communicates with the Trip Management Service to complement the stored trip information. It isolates the dependency with the third-party weather service from the core application logic.
    \item Notification Service: This component manages system notifications regarding trip completion, errors or review requests, to enrich the user’s experience with relevant information. This component handles exclusively in-app and push notifications.
\end{itemize}

\textbf{Data Layer}

These components are responsible for providing data storage and access.

\begin{itemize}
    \item Database Management System (DBMS): This component oversees the storage and persistence of users, trips, bike paths, obstacles and any relevant metadata. It ensures data integrity and consistency and supports querying and indexing for more efficient path discovery. Each service encapsulates its own persistence logic and interacts directly with the DBMS.
\end{itemize}

\textbf{External Services}

These external services are accessed through dedicated integration components to separate the core application logic from third-party dependencies. We assume that they are generally available and reliable, and that they support fault tolerance and graceful degradation policies. The application does not depend entirely on their availability and thus have fallback mechanisms when data cannot be retrieved.

\begin{itemize}
    \item Weather Service: This external component retrieves meteorological data given specific location and time data. This service is exposed as an API that can be consumed by the Weather Integration Service on demand.
    \item Geocoding Service: This external component resolves addresses to coordinates and computes routes between two locations. This service is exposed as an API that is consumed by the Geocoding Integration Service. It can translate user-provided locations into geographic coordinates that can be later presented visually in a map.
\end{itemize}

\begin{center}
    \includegraphics[width=0.9\textwidth]{Images/ComponentView.png}
\end{center}


\subsection{Deployment View}

This section describes the deployment view of the BBP system, outlining the hardware and software components, their configurations, and how their geographical distribution is in a production environment.

\textbf{Mobile Device}

A mobile device (smartphone) is used by cyclists to run the native BBP mobile application on iOS or Android platforms. The device's GPS capabilities are used to collect location data during bike trips. The mobile application then communicates with the backend services over HTTPS. Additionally, the application can also store GPS data when offline using local data buffering which synchronizes with the backend when connectivity is restored.

\textbf{Firewall}

A firewall is positioned at the network perimeter for monitoring of all network traffic from the mobile clients and also to protect the backend services from unauthorized access and potential threats. It filters incoming and outgoing traffic based on predefined security rules, ensuring that only legitimate requests reach the API Gateway. Should any anomalous traffic be detected, the firewall safeguards the backend infrastructure by blocking these unauthorized connections.

It is to be noted that the firewall is positioned before the Load Balancer to ensure that all incoming traffic is inspected and is deemed safe before being distributed to the backend services.

\textbf{Load Balancer}

The Load Balancer distributes the incoming requests from the mobile application evenly across multiple instances of the backend microservices. This ensures optimal resource utilization, responsiveness, and high availability. The load balancer periodically checks the health of Gateway instances automatically routing traffic only to healthy instances, preventing downtime in case of service failures.

\textbf{API Gateway and Proxy Server}

The API Gateway and Proxy Server layer handles all incoming requests from the mobile application, enforcing security policies such as authentication, rate limiting, and routing to the appropriate backend microservice. This layer deals with decryption of incoming HTTPS requests, SSL/TLS certificate management, and outbound requests to third-party services such as OpenWeather API, OpenStreetMap API and OAuth providers. Caching of frequently requested data is also implemented at this layer to reduce database load and improve response times where a request is delt without it ever being passed on to the Application Server.

\textbf{Microservice Application Servers}

The Microservice Application Servers host the core backend services of the BBP system. Each microservice is deployed on its own server instance, allowing for independent scaling and maintenance. The microservices communicate with each other using RESTful APIs and also interact with the database for data storage and retrieval. The microservices include:
 \begin{itemize}
    \item Trip Recording Service - for handling of GPS data, Trip statistics computation, and local buffering.
    \item Path Management Service - for handling of path data insertion by \verb|RegisteredUser|, as well as enforcing publication states, visibility rules, and storage of path data in the database. It also enables path discovery functionality.
    \item Path Scoring Service - for computation of path scores and ranking based on path conditions and obstacles.
    \item Geocoding Integration Service - for integration with the external geocoding service API to resolve geographic locations. 
    \item Weather Integration Service - for integration with weather APIs for trip weather data upon notification of trip completion event from the message brokers.
    \item User Authentication Service - for managing user login, registration, and session management.
    \item Notification Service - for sending notifications to users about events or updates.
\end{itemize}.

\textbf{Database Server}

The Database Server in the BBP system is configured with a clustered setup along with replication to ensure high availability and failover. Each microservice interacts with the database through well-defined schema for its entities. Further PostGIS extension is used to handle geographical data.

\textbf{External Services}

The BBP system integrates with several external services like OpenWeather API, OpenStreetMap API, and OAuth providers at the API Gateway and Proxy Server to enhance the systems functionality.

\textbf{Geographical Distribution and Deployment}

The BBP system is deployed using dockerized containers where each microservice, API Gateway and Proxy Manager Server runs in their own container. Further, the database is deployed in a multi-region setup where the primary region - Italy houses all the microservices, databases which handle 100$\% $ of the traffic under normal conditions with readily available backups of databases along with standby instances of microservices for failover in situations where the primary region becomes unavailable to ensure data redundancy and disaster recovery


\subsection{Runtime View}

In the Runtime View we illustrate the dynamic interactions among the system’s architectural components for a selected set of use cases. User interaction and device-specific events are abstracted by the Mobile User Interface, which represents the system boundary in all sequence diagrams. Only architecturally significant use cases are included, considering that trivial interactions do not contribute additional insight at the design level. The diagrams focus on the complete execution flow to clearly expose component responsibilities, so we intentionally omitted redundant interactions such as caching optimizations and notification handling when they do not affect the overall architectural behavior, even though they are present and play important roles in the production-level system.

\textbf{[UC4] Record Trip}

\includegraphics[width=\textwidth]{Images/Runtime_UC4.png}

This sequence diagram illustrates the runtime interaction among the Mobile User Interface, device sensors, and backend services during trip recording. It shows permission handling, sensor data acquisition, cache buffering, trip lifecycle management, and persistence decisions. The diagram emphasizes backend responsibilities of trip state management while showing how sensor data is safely collected and transmitted during recording, pause, resume, and completion phases. Notice that the backend services do not communicate directly with the device sensors, as all interactions are mediated by the Mobile User Interface component, according to the defined layered architecture principles.

\textbf{[UC6] Enrich Trip with Weather Data}

\includegraphics[width=\textwidth]{Images/Runtime_UC6.png}

This sequence diagram illustrates the process through which completed trips are enriched with meteorological information obtained from an external weather service. It shows how the Trip Recording Service delegates external communication to the Weather Integration Service and how the system handles both successful enrichment and service unavailability. The use case also illustrates the notification flow for asynchronous enrichment events, and thus, will intentionally be omitted from other sequence diagrams to avoid redundancy. We assume that this same flow is followed whenever a service requires communication features from the Notification Service.

\newpage
\textbf{[UC7] Manually Insert Bike Path Information}

\includegraphics[width=\textwidth]{Images/Runtime_UC7.png}

This sequence diagram illustrates the behavior associated with manual path data insertion by a \verb|RegisteredUser|. It shows how the Path Management Service validates route information through the Geocoding Integration Service, manages user-provided path details, and persists the resulting data. Alternative flows illustrate invalid routes and external service unavailability, highlighting graceful degradation, which will be specifically emphasized in communication with external services.

\newpage
\textbf{[UC8] Confirm Automatically Acquired Path Information}  

\includegraphics[width=\textwidth]{Images/Runtime_UC8.png}

This sequence diagram illustrates the review and confirmation process for automatically acquired path data. It shows how the system retrieves pending path information, allows users to confirm or modify it, and handles publication decisions. The sequence emphasizes backend control of review state and publication status without involving external services.

\newpage
\textbf{[UC9] Search Bike Paths}

\includegraphics[width=\textwidth]{Images/Runtime_UC9.png}

This sequence diagram illustrates the collaboration among components during path querying and discovery. It shows how origin and destination queries are processed by the Path Management Service, how external geocoding is handled by an integration component, and how path scoring and ranking are delegated to the Path Scoring Service. The diagram also illustrates graceful handling of geocoding service unavailability.

\textbf{[UC10] Visualize Bike Paths on Map}

\begin{center}
    \includegraphics[width=0.9\textwidth]{Images/Runtime_UC10.png}
\end{center}

This sequence diagram illustrates the visualization of existing paths on an interactive map. It focuses on retrieving path geometry from the backend and rendering it at the presentation layer. The use case also shows the optional transition to trip recording, explicitly linking visualization with the trip recording workflow (UC4) without duplicating its logic.


\subsection{Component Interfaces}

This section provides a summary of all the methods within the interfaces of the BBP system. All internal system components will rely on REST API interfaces. Note that the methods have been named with an initial prefix indicating the corresponding operation type (get/put/post/delete). Regardless of the provider, we have assumed that there are only a few methods available for external components.

The names of the classes used as method parameters were chosen to be as self-explanatory as possible. However, to avoid ambiguity, note the following:

\begin{itemize}
    \item ``User'' represents a generic user, while ``RegisteredUser'' and ``UnregisteredUser'' are subclasses of User and are used when the parameter needs to specify a particular type of user.
    \item ``Trip'' represents a recorded bike trip with GPS data and computed statistics.
    \item ``Path'' represents a bike path published by users, with geometry (LineString) and status information.
    \item ``PathScore'' is a computed metric (0.0-1.0) based on path status quality and routing effectiveness.
    \item ``Obstacle'' represents a hazard or challenge on a path (Pothole , Construction , Debris or Infrastructure).
    \item ``TripData'' includes metadata about a trip (distance\_km, duration\_seconds, avg\_speed\_kmh, max\_speed\_kmh, elevation\_gain\_m).
    \item ``WeatherData'' includes conditions at trip location (temperature\_c, humidity, wind\_speed\_kmh, precipitation\_mm, condition).
\end{itemize}

\textbf{API Gateway Interface}
% Main entry point for all client requests. Handles authentication, routing, and rate limiting.

\begin{itemize}
    \item[-] get\_tripHistory(UserID, DateRange)
    \item[-] get\_tripDetails(TripID)
    \item[-] get\_pathInfo(PathID)
    \item[-] get\_userProfile(UserID)
\end{itemize}

\begin{itemize}
    \item[-] post\_login(Email, Password)
    \item[-] post\_register(Email, Password, UserType)
    \item[-] post\_oauthLogin(Provider, Token)
    \item[-] post\_startTrip(UserID)
    \item[-] post\_stopTrip(UserID, TripID)
    \item[-] post\_submitPath(UserID, PathData, Geometry, ObstacleList)
    \item[-] post\_queryPaths(Origin, Destination)
    \item[-] post\_publishPath(UserID, PathID)
\end{itemize}

\begin{itemize}
    \item[-] put\_updateUserProfile(UserID, UserData, PreferencesList)
\end{itemize}

\begin{itemize}
    \item[-] delete\_draftPath(UserID, PathID)
\end{itemize}

\textbf{Trip Recording Service Interface}
% Handles GPS data acquisition, trip statistics computation, and local buffering.

\begin{itemize}
    \item[-] post\_startRecording(UserID) -- Initiates GPS data collection
    \item[-] post\_addGPSPoint(TripID, Latitude, Longitude, Timestamp, Accuracy, InstantaneousSpeed) -- Add single GPS reading
    \item[-] post\_stopRecording(UserID, TripID) -- Finalize trip recording and compute statistics
\end{itemize}

\begin{itemize}
    \item[-] get\_realtimeMetrics(TripID) -- Get current trip statistics during recording
    \item[-] get\_tripMetrics(TripID) -- Get finalized trip statistics with weather enrichment
\end{itemize}

\begin{itemize}
    \item[-] put\_pauseTrip(TripID) -- Pause GPS recording temporarily
    \item[-] put\_resumeTrip(TripID) -- Resume GPS recording after pause
\end{itemize}

\textbf{Path Management Service Interface}
% This service manages manual path entry and its creation workflow, along with path discovery and ranking.

\begin{itemize}
    \item[-] post\_createDraftPath(UserID, PathName, PathDescription, Status) -- Create new path in Draft state
    \item[-] post\_addPathGeometry(UserID, PathID, Geometry) -- Add GeoJSON LineString to path
    \item[-] post\_addObstacle(UserID, PathID, ObstacleType, Location) -- Add obstacle/hazard
    \item[-] post\_savePath(UserID, PathID) -- Transition path from Draft to Save state - not published
    \item[-] post\_publishPath(UserID, PathID) -- Transition path from Draft to Published state
\end{itemize}

\begin{itemize}
    \item[-] get\_draftPaths(UserID) -- Retrieve all draft paths for user
    \item[-] get\_publishedPaths(UserID) -- Retrieve all published paths for user
    \item[-] get\_pathDetails(PathID) -- Retrieve complete path information with geometry and obstacles
\end{itemize}

\begin{itemize}
    \item[-] delete\_draftPath(UserID, PathID) -- Remove path (only in Draft state)
\end{itemize}

\begin{itemize}
    \item[-] post\_queryPaths(Origin, Destination) -- Public Origin-Destination query endpoint
\end{itemize}

\begin{itemize}
    \item[-] get\_pathScore(PathID) -- Get current PathScore calculation through Path Scoring Service
    \item[-] get\_cachedQueryResult(Origin, Destination) -- Check if results cached
\end{itemize}

\textbf{Path Scoring Service Interface}
% Computes path scores and rankings based on path conditions and obstacles.

\begin{itemize}
    \item[-] request\_scoreComputation(PathList) -- Triggered by Path Management Service during path discovery
\end{itemize}

\begin{itemize}
    \item[-] compute\_pathScore(PathStatus, ObstacleList) -- Compute score for a single path
    \item[-] rank\_paths(PathList) -- Order paths by descending PathScore
\end{itemize}


\textbf{User Authentication Service Interface}
% Manages user registration, login, OAuth federation, JWT tokens.

\begin{itemize}
    \item[-] post\_register(Email, Password, UserType) -- Create new user account (RegisteredUser or UnregisteredUser)
    \item[-] post\_login(Email, Password)
    \item[-] post\_oauthLogin(Provider, AuthCode) -- OAuth login (Google, Apple)
    \item[-] post\_logout(UserID, AccessToken) -- Invalidate user session
\end{itemize}

\begin{itemize}
    \item[-] get\_userProfile(UserID) -- Retrieve user profile and preferences
\end{itemize}

\begin{itemize}
    \item[-] put\_updateProfile(UserID, UserData, PreferencesList, ProfilePicture) -- Update user information
    \item[-] put\_changePassword(UserID, OldPassword, NewPassword) -- Change account password
\end{itemize}

\textbf{Geocoding Integration Service Interface}
% Resolves geographic locations and computes routes using OpenStreetMap API. Handles timeouts and service unavailability.

\begin{itemize}
    \item[-] request\_routeQuery(Origin, Destination) -- Triggered by Path Management Service during path discovery
    \item[-] request\_reverseGeocoding(Coordinates) -- Triggered by Trip Recording Service for location resolution
\end{itemize}

\begin{itemize}
    \item[-] publish\_routesResolved(QueryID, RouteList) -- Emitted when candidate routes are successfully retrieved
    \item[-] publish\_geocodingFailed(QueryID, ErrorMessage) -- Emitted when geocoding or routing requests fail or time out (5s timeout)
\end{itemize}

\begin{itemize}
    \item[-] get\_coordinates(Address) -- Resolve address to geographic coordinates via OpenStreetMap API
    \item[-] get\_routes(Origin, Destination) -- Retrieve candidate routes between two locations
    \item[-] get\_cachedRoutes(Origin, Destination) -- Check cache for previously resolved routes
\end{itemize}

\textbf{Weather Integration Service Interface}
% Queries OpenWeather API, caches results, handles timeouts. Uses event-driven async pattern via RabbitMQ.

\begin{itemize}
    \item[-] subscribe\_tripCompleted(TripID, Location, Timestamp) -- Triggered by Trip Recording Service
\end{itemize}

\begin{itemize}
    \item[-] publish\_weatherEnriched(TripID, WeatherData) -- Emitted when weather data successfully retrieved
    \item[-] publish\_weatherFailed(TripID, ErrorMessage) -- Emitted when weather enrichment times out (5s timeout)
\end{itemize}

\begin{itemize}
    \item[-] get\_currentWeather(Latitude, Longitude) -- Query OpenWeather API
    \item[-] get\_cachedWeather(Latitude, Longitude) -- Check cache
    \item[-] post\_enrichTrip(TripID, WeatherData) -- Return weather data with trip
\end{itemize}

\textbf{Notification Service Interface}
% Listens to events, generates notifications, sends push and in-app.

\begin{itemize}
    \item[-] subscribe\_pathPublished() -- From Path Management Service
    \item[-] subscribe\_tripCompleted() -- From Trip Recording Service
    \item[-] subscribe\_weatherEnriched() -- From Weather Integration Service
    \item[-] subscribe\_weatherFailed() -- From Weather Integration Service
\end{itemize}

\textbf{Database Server (DBMS) Interface}

Each of the following methods represent database operations performed on a relational database system. The prefix indicate the type of operation: "query" corresponds to data retrieval or read, "create" corresponds to insertion of new data, "store" to update or add information to existing objects, "delete" to remove entries.
% PostgreSQL with PostGIS extensions. Each method corresponds to specific SQL operations in parametric form.

\begin{itemize}
    \item[-] query\_trips(UserID) -- Retrieve all trips for user
    \item[-] query\_trip(TripID) -- Retrieve specific trip with all metrics
    \item[-] query\_paths(UserID) -- Retrieve all paths created by user
    \item[-] query\_path(PathID) -- Retrieve path with geometry, obstacles, ratings
    \item[-] query\_userProfile(UserID) -- Get user data and preferences
    \item[-] query\_search(Origin, Destination) -- Execute Origin-Destination path search
    \item[-] query\_userTrips(UserID, DateRange) -- Retrieve trips in date range
    \item[-] query\_pathRatings(PathID) -- Get all ratings and reviews for path
\end{itemize}

\begin{itemize}
    \item[-] create\_trip(UserID, TripData, GPSPoints) -- Create trip record with GPS coordinates
    \item[-] create\_path(UserID, PathData, Geometry, LocationList) -- Create path with geometry
    \item[-] create\_user(Email, Password, UserType) -- Create user account
\end{itemize}

\begin{itemize}
    \item[-] store\_tripMetrics(TripID, DistanceKm, DurationSeconds, Statistics) -- Store computed statistics
    \item[-] store\_tripWeather(TripID, WeatherData) -- Attach weather to trip
    \item[-] store\_pathPublished(PathID, PublishedState, Timestamp) -- Mark path published
    \item[-] store\_userProfile(UserID, UserData, PreferencesList) -- Update user profile
\end{itemize}

\begin{itemize}
    \item[-] delete\_draftPath(PathID) -- Remove path in Draft state
    \item[-] delete\_trip(TripID) -- Remove trip from personal history (not once published)
\end{itemize}

\textbf{Cache Server Interface}
% In-memory caching for performance optimization with TTL-based expiration.

\begin{itemize}
    \item[-] cache\_geocodingResult(Address, Coordinates, TTL=24h) -- Cache address to coordinates mappings
    \item[-] cache\_weatherData(Location, WeatherData, TTL=24h) -- Cache weather results
\end{itemize}

\begin{itemize}
    \item[-] get\_cachedTrip(TripID) -- Retrieve cached Trip data
    \item[-] get\_cachedWeather(Location) -- Retrieve cached weather
    \item[-] get\_cachedQueryResult(Query) -- Retrieve cached search results
    \item[-] get\_cachedSession(UserID) -- Validate session token
\end{itemize}

\begin{itemize}
    \item[-] invalidate\_tripCache(TripID) -- Clear cache for a trip
    \item[-] invalidate\_queryCache(Region) -- Clear cache for geographic region
    \item[-] invalidate\_geocodingCache(Address) -- Clear address cache
    \item[-] invalidate\_weatherCache(Location) -- Clear weather cache
    \item[-] invalidate\_sessionCache(UserID) -- Clear session cache
\end{itemize}


\subsubsection{External Service Interfaces}

\textbf{OpenWeather API}

\begin{itemize}
    \item[-] GET /data/3.0/onecall -- Get current and forecast weather
    
    Parameters: latitude, longitude, units (metric), appid
    
    Response: { current: { temp, humidity, wind\_speed, description }, alerts: [AlertData] }
    
    \item[-] GET /data/3.0/onecall/timemachine -- Get historical weather data
    
    Parameters: latitude, longitude, dt (unix timestamp), appid
    
    Response: Historical weather data for past timestamps
    
    Timeout: 5 seconds (hard timeout with graceful degradation)
\end{itemize}

\textbf{OpenStreetMap API}

\begin{itemize}
    \item[-] GET /search?q=address\&format=json -- Geocode address to coordinates
    
    Response: { latitude, longitude, display\_name, osm\_type }
    
    \item[-] GET /reverse?lat=latitude\&lon=longitude\&format=json -- Reverse geocode coordinates to address
    
    Response: Address and location details from coordinates
\end{itemize}


\subsection{Selected Architectural Style}

\textbf{4 Tier Architecture}

With a 4-Tire Architecture, the BBP system has a clear seperation between the user and the data by having many intermediate layers. This approach allows for a decoupled system where each layer has some specific responsibilities providing a flexible, scalable and secure system. The presentation layer is responsible for user interaction, the API Gateway and network components serve the function of handling certificates, enforcing security and also in caching. The backend application layer handles the business logic and processing with the help of microservices, and the data layer manages persistent storage. This separation of concerns facilitates easier maintenance, when it comes to scaling the Frontend horizontaly to accomodate more cyclists, and flexibility in development. 

\textbf{Microservice Architecture}

The BestBikePaths system employs a microservice architecture where the core functionalities are divided into smaller, independently deployable services. Each microservice is responsible for a specific business capability such as trip recording, path management, user authentication, weather integration, and notifications. This approach allows for rapid development, deployment, and scaling of these services. This also prevents overloading of a single application further enhancing fault isolation, where a failure in one microservice does not necessarily impact the entire system. For example, the PathQueryService and TripRecordingService can be scaled or replicated independently during peak usage times without over provisioning the entire system.

\textbf{API Gateway Pattern}

To facilitate the communication between the mobile application and the backend microservices, the BBP system employs an API Gateway pattern. The API Gateway serves as the main entry point for all client requests, handling authentication, routing, rate limiting, and load balancing. This provides a unified interface for interaction. It also enhances security by enforcing consistent policies and protecting the backend services.

\textbf{Circuit Breaker Pattern}

To guarantee system resilience and availability, especially with external services such as OpenStreetMap API and OpenWeather API, which are prone to latency and failures, the system makes use of the circuit breakers. They act by preventing cascading failures by preventing calls to an external service that is currently failing or experiencing high latency. This allows the system to degrade gracefully, providing fallback responses or alternative flows when external dependencies are unavailable. This is experienced first hand in the Weather Integration Service where a hard timeout of 5 seconds is enforced when querying the OpenWeather API. In case of a timeout, the system gracefully degrades by saving the trip recording without the weather data. 

\textbf{State Pattern for Trip and Path Lifecycle}

The system includes entities such as Trips and user-created Paths that have distinct lifecycle states. For instance, a Trip usually transits through different state like "Recording", "Paused", and "Completed", while a Path can be in states like "Draft", "Saved", and "Published". The State Pattern is employed to manage these lifecycle transitions explicitly. Each state encapsulates the behavior associated with that particular state, allowing for clear enforcement on what operations are permissible in each stage. 

\subsection{Other Design Decisions}

\textbf{Proxy Manager}

The presence of a proxy manager along with the API Gateway adds an additional layer of security and abstraction between the client and backend services. The Proxy manager usually handles the decryption of incoming HTTPS requests and SSL/TTL certificates. It also helps in managing outbound requests to third-party services like  OpenWeather API, OpenStreetMap API and OAuth providers in the BBP system. This separation of concerns allows the API Gateway to focus on routing, authentication, and rate limiting, while the Proxy Manager can deal with other network tasks like caching where the manager stores copies of frequently requested data, conducting security checks before sending requests to the main backend server.

\textbf{Rate limiting at API Gateway}

To protect the main backend microservices from abuse and also from denial-of-service attacks, rate limiting implementation at the API gateway ensure that each user can only make a certain number of requests within a stipulated timeframe. This facilitates fairness between users usage by maintaining an experience which is consistent.

\textbf{Timeouts and Graceful Degradation}

with integration of external services like OpenWeather API for weathersnashots, OpenStreetMap API for geocoding it is crucial to implement timeouts to prevent the system from hanging indefinitely while waiting for a response. Hence,the BBP system enforces a hard timeout for these external services like a timeout of 5 seconds for weather data retrieval. Incase the external service does not respond within the stipulated time, the system gracefully degrades by saving the trip recording without the weather data. This ensures that users can still complete their trips and have their trip data recorded even if the weather service is temporarily unavailable. This can be retroactively added to the trip data when the weather service becomes available again.